// NOTICE: This file is generated by Rollup. To modify it,
// please instead edit the ESM counterpart and rebuild with Rollup (npm run build).
'use strict';

const selectorParser = require('postcss-selector-parser');
const selectors = require('../../reference/selectors.cjs');
const validateTypes = require('../../utils/validateTypes.cjs');
const getRuleSelector = require('../../utils/getRuleSelector.cjs');
const isCustomSelector = require('../../utils/isCustomSelector.cjs');
const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule.cjs');
const isStandardSyntaxSelector = require('../../utils/isStandardSyntaxSelector.cjs');
const optionsMatches = require('../../utils/optionsMatches.cjs');
const parseSelector = require('../../utils/parseSelector.cjs');
const report = require('../../utils/report.cjs');
const ruleMessages = require('../../utils/ruleMessages.cjs');
const uniteSets = require('../../utils/uniteSets.cjs');
const validateOptions = require('../../utils/validateOptions.cjs');

const { isPseudo, isPseudoElement, isTag } = selectorParser;

const ruleName = 'selector-no-deprecated';

const messages = ruleMessages(ruleName, {
	expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"`,
	rejected: (selector) => `Unexpected deprecated selector "${selector}"`,
});

const meta = {
	url: 'https://stylelint.io/user-guide/rules/selector-no-deprecated',
	fixable: true,
};

const DEPRECATED_TYPE_SELECTORS = uniteSets(
	selectors.deprecatedHtmlTypeSelectors,
	selectors.deprecatedSvgTypeSelectors,
);

const DEPRECATED_TYPE_SELECTOR_PATTERN = new RegExp(
	`\\b(?:${Array.from(DEPRECATED_TYPE_SELECTORS).join('|')})\\b`,
	'i',
);

/** Combines referenced and vendor-prefixed deprecated pseudo-classes. */
const DEPRECATED_PSEUDO_CLASSES = uniteSets(
	selectors.deprecatedPseudoClasses,
	new Set(['-webkit-any', '-moz-any']),
);

/** @type {Record<string, string | null>} */
const DEPRECATED_PSEUDO_CLASSES_REMAP = {
	'focus-ring': 'focus-visible',
	matches: 'is',
	'-webkit-any': 'is',
	'-moz-any': 'is',
};

/** @type {Record<string, string | null>} */
const DEPRECATED_PSEUDO_ELEMENTS_REMAP = {
	content: 'slotted',
};

const DEPRECATED_PSEUDOS = uniteSets(DEPRECATED_PSEUDO_CLASSES, selectors.deprecatedPseudoElements);

const DEPRECATED_PSEUDO_PATTERN = new RegExp(
	`\\:(?:${Array.from(DEPRECATED_PSEUDOS).join('|')})\\b`,
	'i',
);

/** @type {import('stylelint').CoreRules[ruleName]} */
const rule = (primary, secondaryOptions) => {
	return (root, result) => {
		const validOptions = validateOptions(
			result,
			ruleName,
			{ actual: primary },
			{
				actual: secondaryOptions,
				possible: {
					ignoreSelectors: [validateTypes.isString, validateTypes.isRegExp],
				},
				optional: true,
			},
		);

		if (!validOptions) return;

		root.walkRules((ruleNode) => {
			if (!isStandardSyntaxRule(ruleNode)) return;

			const selector = getRuleSelector(ruleNode);

			const hasDeprecatedPseudo = DEPRECATED_PSEUDO_PATTERN.test(selector);
			const hasDeprecatedTypeSelector = DEPRECATED_TYPE_SELECTOR_PATTERN.test(selector);

			if (!hasDeprecatedPseudo && !hasDeprecatedTypeSelector) return;

			const resolvedRoot = parseSelector(selector, result, ruleNode);

			if (!resolvedRoot) return;

			resolvedRoot.walk((node) => {
				if (hasDeprecatedPseudo && isPseudo(node)) {
					const { value, sourceIndex } = node;

					if (!isStandardSyntaxSelector(value)) return;

					if (isCustomSelector(value)) return;

					let namedValue;
					let mappedValue;

					if (isPseudoElement(node)) {
						namedValue = value.slice(2);
						const normalized = namedValue.toLowerCase();

						if (!selectors.deprecatedPseudoElements.has(normalized)) return;

						const remap = DEPRECATED_PSEUDO_ELEMENTS_REMAP[normalized];

						if (remap) mappedValue = `::${remap}`;
					} else {
						namedValue = value.slice(1);
						const normalized = namedValue.toLowerCase();

						if (!DEPRECATED_PSEUDO_CLASSES.has(normalized)) return;

						const remap = DEPRECATED_PSEUDO_CLASSES_REMAP[normalized];

						if (remap) mappedValue = `:${remap}`;
					}

					if (optionsMatches(secondaryOptions, 'ignoreSelectors', namedValue)) return;

					let fix;
					let message;
					let messageArgs = [];

					if (typeof mappedValue === 'string') {
						message = messages.expected;
						messageArgs = [value, mappedValue];
						fix = () => {
							node.value = mappedValue;
							ruleNode.selector = resolvedRoot.toString();
						};
					} else {
						message = messages.rejected;
						messageArgs = [value];
					}

					report({
						result,
						ruleName,
						message,
						messageArgs,
						node: ruleNode,
						index: sourceIndex,
						endIndex: sourceIndex + value.length,
						fix: {
							apply: fix,
							node: ruleNode,
						},
					});
				}

				if (hasDeprecatedTypeSelector && isTag(node)) {
					const { sourceIndex, value } = node;
					const normalizedValue = value.toLowerCase();

					if (optionsMatches(secondaryOptions, 'ignoreSelectors', value)) return;

					if (
						!selectors.deprecatedHtmlTypeSelectors.has(normalizedValue) &&
						!selectors.deprecatedSvgTypeSelectors.has(value)
					)
						return;

					report({
						result,
						ruleName,
						message: messages.rejected,
						messageArgs: [value],
						node: ruleNode,
						index: sourceIndex,
						endIndex: sourceIndex + value.length,
					});
				}
			});
		});
	};
};

rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;

module.exports = rule;
