// NOTICE: This file is generated by Rollup. To modify it,
// please instead edit the ESM counterpart and rebuild with Rollup (npm run build).
'use strict';

const cssTree = require('css-tree');
const getRuleSelector = require('../../utils/getRuleSelector.cjs');
const typeGuards = require('../../utils/typeGuards.cjs');
const isStandardSyntaxRule = require('../../utils/isStandardSyntaxRule.cjs');
const report = require('../../utils/report.cjs');
const ruleMessages = require('../../utils/ruleMessages.cjs');
const validateOptions = require('../../utils/validateOptions.cjs');

const ruleName = 'selector-nesting-notation';

const messages = ruleMessages(ruleName, {
	expected: (unfixed, fixed) => `Expected "${unfixed}" to be "${fixed}"`,
});

const meta = {
	url: 'https://stylelint.io/user-guide/rules/selector-nesting-notation',
	fixable: true,
};

/**
 * @typedef {{type: 'add-nesting' | 'remove-nesting', index: number, endIndex: number}} Violation
 * Represents a violation found in a selector that needs fixing
 */

/** @type {import('stylelint').CoreRules[ruleName]} */
const rule = (primary) => {
	return (root, result) => {
		const validOptions = validateOptions(result, ruleName, {
			actual: primary,
			possible: ['explicit', 'implicit'],
		});

		if (!validOptions) return;

		root.walkRules((ruleNode) => {
			if (!isStandardSyntaxRule(ruleNode)) return;

			if (!ruleNode.parent || !typeGuards.isRule(ruleNode.parent)) return;

			const ruleSelector = getRuleSelector(ruleNode);
			let ast;

			try {
				ast = cssTree.parse(ruleSelector, {
					context: 'selectorList',
					positions: true,
				});
			} catch {
				return;
			}

			if (ast.type !== 'SelectorList') return;

			// Collect all violations and build new selector string
			/** @type {Array<Violation>} */
			const violations = [];

			ast.children.forEach((cssTreeSelector) => {
				if (cssTreeSelector.type === 'Selector') {
					const violation = checkSelector(cssTreeSelector, primary);

					if (violation) {
						violations.push(violation);
					}
				}
			});

			// Report only one violation (the first one) with fix for all modifications
			if (violations.length > 0) {
				const fixedSelector = applyFixes(ast, primary);
				const firstViolation = violations[0];

				if (!firstViolation) return;

				report({
					message: messages.expected,
					messageArgs: [ruleSelector, fixedSelector],
					node: ruleNode,
					index: firstViolation.index,
					endIndex: firstViolation.endIndex,
					ruleName,
					result,
					fix:
						fixedSelector !== ruleSelector
							? {
									apply: () => {
										ruleNode.selector = fixedSelector;
									},
									node: ruleNode,
								}
							: undefined,
				});
			}
		});
	};
};

/**
 * Check a CSS selector for nesting violations based on the primary option
 * @param {import('css-tree').Selector} selector
 * @param {string} primary
 * @returns {Violation | null}
 */
function checkSelector(selector, primary) {
	if (selector.type !== 'Selector') return null;

	const hasNesting = hasNestingSelector(selector);
	const startsWithComb = startsWithCombinator(selector);

	if (primary === 'explicit') {
		// In explicit mode, require & for selectors that start with combinators
		if (startsWithComb && !hasNesting) {
			if (!selector.loc) return null;

			return {
				type: 'add-nesting',
				index: selector.loc.start.offset,
				endIndex: selector.loc.end.offset,
			};
		}
	} else if (primary === 'implicit') {
		// In implicit mode, disallow unnecessary & when followed by combinator
		if (hasNesting && canUseImplicitNesting(selector)) {
			const nestingNode = findNestingSelector(selector);

			if (!nestingNode || !nestingNode.loc) return null;

			const index = nestingNode.loc.start.offset;
			const endIndex = nestingNode.loc.end.offset;

			// Find the space after & if it exists
			let spaceLength = 0;
			const nextSibling = getNextSibling(selector, nestingNode);

			if (nextSibling && nextSibling.type === 'Combinator') {
				if (nextSibling.name === ' ') {
					// Descendant combinator - remove the space
					spaceLength = nextSibling.loc
						? nextSibling.loc.end.offset - nextSibling.loc.start.offset
						: 1;
				} else {
					// Non-space combinator (>, +, ~) - remove the preceding space
					spaceLength = 1; // Always remove one space before the combinator
				}
			}

			return {
				type: 'remove-nesting',
				index,
				endIndex: endIndex + spaceLength,
			};
		}
	}

	return null;
}

/**
 * Apply all fixes by building new selector string from individual selectors
 * @param {import('css-tree').SelectorList} selectorList
 * @param {string} primary
 * @returns {string}
 */
function applyFixes(selectorList, primary) {
	/** @type {string[]} */
	const fixedSelectors = [];

	selectorList.children.forEach((selector) => {
		if (selector.type !== 'Selector') return;

		const violation = checkSelector(selector, primary);
		let selectorText = cssTree.generate(selector);

		if (violation?.type === 'add-nesting') {
			// Add & before the selector, ensuring proper spacing
			selectorText = `& ${selectorText}`;
		} else if (violation?.type === 'remove-nesting') {
			// Remove & and following space from selector
			selectorText = selectorText.substring(selectorText.startsWith('& ') ? 2 : 1);
		}

		// Fix spacing issues from CSS Tree generate()
		// CSSTree sometimes omits spaces after combinators (>, +, ~) in generated output
		// This regex adds the required space to ensure valid CSS formatting
		selectorText = selectorText.replace(/([>+~])([a-z#.])/gi, '$1 $2');

		fixedSelectors.push(selectorText);
	});

	return fixedSelectors.join(', ');
}

/**
 * Check if a selector contains a nesting selector (&)
 * @param {import('css-tree').Selector} selector
 * @returns {boolean}
 */
function hasNestingSelector(selector) {
	let hasNesting = false;

	selector.children.forEach((child) => {
		if (child.type === 'NestingSelector') {
			hasNesting = true;
		}
	});

	return hasNesting;
}

/**
 * Find the first nesting selector (&) node in a selector
 * @param {import('css-tree').Selector} selector
 * @returns {import('css-tree').NestingSelector | null}
 */
function findNestingSelector(selector) {
	let nestingNode = null;

	selector.children.forEach((child) => {
		if (child.type === 'NestingSelector') {
			nestingNode = child;
		}
	});

	return nestingNode;
}

/**
 * Check if a selector starts with a combinator (>, +, ~, or space)
 * @param {import('css-tree').Selector} selector
 * @returns {boolean}
 */
function startsWithCombinator(selector) {
	const {
		children: { first: firstChild },
	} = selector;

	return Boolean(firstChild && firstChild.type === 'Combinator');
}

/**
 * Check if a selector with & can use implicit nesting (& can be removed)
 * This is true when the selector starts with & followed by a combinator
 * @param {import('css-tree').Selector} selector
 * @returns {boolean}
 */
function canUseImplicitNesting(selector) {
	const firstChild = selector.children.first;

	// Must start with &
	if (!firstChild || firstChild.type !== 'NestingSelector') return false;

	// Find the next sibling after the nesting selector using getNextSibling
	const secondChild = getNextSibling(selector, firstChild);

	// Must be followed by a combinator to be removable
	return secondChild !== null && secondChild.type === 'Combinator';
}

/**
 * Get the next sibling node in a selector's children list
 * @param {import('css-tree').Selector} selector
 * @param {import('css-tree').CssNode} node
 * @returns {import('css-tree').CssNode | null}
 */
function getNextSibling({ children }, node) {
	let found = false;

	for (const child of children) {
		if (found) return child;

		if (child === node) found = true;
	}

	return null;
}

rule.ruleName = ruleName;
rule.messages = messages;
rule.meta = meta;

module.exports = rule;
